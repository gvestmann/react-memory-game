{"version":3,"sources":["components/Header.js","components/Card.js","components/CardBoard.js","components/DealCards.js","components/Footer.js","components/App.js","reportWebVitals.js","index.js"],"names":["Header","Card","clickHandler","id","turnedOver","name","freezeBoard","matchingCards","className","onClick","src","alt","CardBoard","cards","map","card","includes","dealCards","array","i","length","j","Math","floor","random","temp","randomizeCards","reduce","newCards","push","Footer","href","App","useState","startCards","setTurnedOver","setMatchingCards","setFreezeBoard","useEffect","isSameCard","doCardsMatch","clicked1","find","clicked2","refreshBoard","setTimeout","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.396c7e8a.chunk.js","sourcesContent":["import React from \"react\"\n\n// Basic component for build the header\nfunction Header() {\n\n    // Function returns JSX-code\n    return (\n        <header>\n            <h1>NEVER FORGET!</h1>\n            <h2>MEMORY GAME BUILT WITH REACT</h2>\n        </header>\n    )\n}\n\n// Function exported\nexport default Header","// Import of React + some extra goodies from PropTypes component\nimport React from \"react\"\nimport PropTypes from \"prop-types\"\n\n// This function handles the single card element. It's provided functions and arrays to work with through-out the game. It returns a JSX-code using the provided parameters.\nfunction Card({clickHandler, id, turnedOver, name, freezeBoard, matchingCards}) {\n    return (\n    // This is the card's container. On click if will check if the board is frozen, or else the clickHandler function. Below is the card's image. If the card is turned over or is a matching card, the front side is used as src. Otherwise, the backside is shown.\n    <div className=\"card__container\"  onClick={() => freezeBoard ? null : clickHandler(id)}>\n        <img src={turnedOver || matchingCards ?  `https://raw.githubusercontent.com/gvestmann/react-memory-game/main/src/img/${name}.jpg` : `https://raw.githubusercontent.com/gvestmann/react-memory-game/main/src/img/back-side.png`} alt={id}/>\n    </div>\n    )\n}\n\n// Here are defenitions for the prop-types being used in the function\nCard.propTypes = {\n    clickHandler: PropTypes.func.isRequired,\n    turnedOver: PropTypes.bool.isRequired,\n    matchingCards: PropTypes.bool.isRequired,\n    id: PropTypes.number.isRequired,\n    name: PropTypes.number.isRequired,\n    freezeBoard: PropTypes.bool.isRequired\n}\n\n// Our card is then exported\nexport default Card","// Import of React, Prop-Type extras and my single-card-component\nimport React from \"react\"\nimport PropTypes from \"prop-types\"\nimport Card from \"./Card\"\n\n// The card table takes in various props, including the clickHandler an arrays used in setState \nfunction CardBoard ({cards, turnedOver, clickHandler, freezeBoard, matchingCards}) {\n    return  (\n        // Returns JSX-code. It maps through the cards array and generates all 16 (8x2) cards with all data and functions that the element needs to take in. Most of them include that card's ID.\n        <div className=\"table\">\n            {cards.map((card) => (\n                <Card \n                name={card.name}\n                key={card.id}\n                id={card.id}\n                turnedOver={turnedOver.includes(card.id)}\n                clickHandler={clickHandler}\n                freezeBoard={freezeBoard || matchingCards.includes(card.id)}\n                matchingCards={matchingCards.includes(card.id)}\n                />\n            )\n            )}\n        </div>\n    )\n}\n\n// Here the props are defined by type.\nCardBoard.propTypes = {\n    cards: PropTypes.arrayOf(PropTypes.shape({})).isRequired,\n    turnedOver: PropTypes.arrayOf(PropTypes.number).isRequired,\n    clickHandler: PropTypes.func.isRequired,\n    freezeBoard: PropTypes.bool.isRequired,\n    matchingCards: PropTypes.arrayOf(PropTypes.number).isRequired,\n\n}\n\n// And the game board is exported\nexport default CardBoard","// You could call this the start-up function, it deals and randomizes that cards\nfunction dealCards() {\n    // Create a ID variable to put all the cards in\n    let id = 0\n\n    // I simply named my cards from letters 1-8 to keep it simple (just like the card's images). Then the reduce()-method is used to build up the deck. \n    const cards = [1, 2, 3, 4, 5, 6, 7, 8].reduce((newCards, name) => {\n        // Next an object is pushed on to the newCards, iterating the ID with +1 and using the card names seen above\n        newCards.push({\n            id: id++,\n            name\n        })\n        // The same is then done again, since a memory game depends on having to identical cards of each\n        newCards.push({\n            id: id++,\n            name\n        })\n        // Finally the newCards array is delivered\n        return newCards\n    }, [])\n\n    // After this exercise, we call the randomize function below, using our cards are parameters\n    return randomizeCards(cards)\n}\n\n// This function randomizes the order of the cards, so that they don't display in the DOM side-by-side. I'm using the Durstenfeld shuffle algorithm.\nfunction randomizeCards(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n    }\n    return array\n}\n\n// .. and now we export our dealt cards! \nexport default dealCards","import React from \"react\"\n\n// Basic component for build the footer\nfunction Footer() {\n\n    // Function returns JSX-code\n    return (\n        <footer>\n            <h3>Illustrations by <a href=\"https://www.instagram.com/solvidunn/\">Sölvi Dúnn</a></h3>\n        </footer>\n    )\n}\n\n// Export compontent/function\nexport default Footer","// Standard import of React + extra goodies from useState & useEffect\nimport React, {useState, useEffect} from \"react\"\n// Import of my components for build the app\nimport Header from \"./Header\"\nimport CardBoard from \"./CardBoard\"\nimport dealCards from \"./DealCards\"\nimport Footer from \"./Footer\"\nimport \"./style.css\"\n\n// The app's function - this all will be exported to Index.js which then sews this together\nfunction App() {\n\n\n  // Here we utilize the setState method. We use a few different arrays and functions for build the state. Most of the states start as an empty array\n\n  // Cards variable is used for storing our game cards. The function is for setting the cards to the state\n  const [cards, startCards] = useState([])\n\n\n  // The varible is used for storing which cards have been turned over and the function later for setting the state\n  const [turnedOver, setTurnedOver] = useState([])\n\n\n  // The variable is for storing those cards which have been found matching and they are then set to the current state.\n  const [matchingCards, setMatchingCards] = useState([])\n\n\n  // This is used for de-activating the game board once a user has click 2 cards, so the 3 one won't be clicked as well. To start with the useState is \"false\", that is, the board is infact active and ready to be played\n  const [freezeBoard, setFreezeBoard] = useState(false)\n\n\n  // Here useEffect sets the cards to the state, with the dealCards function/component as a parameter. The second parameter is an empty array to start with.\n  useEffect(() => {\n    startCards(dealCards())\n  }, [])\n\n\n  // Here's a function for managing all the stuff when the user clicks a card. It takes in that clicked card's ID.\n  const clickHandler = (id) => {\n    // I freezes the board to start with chaning the state to \"true\"\n    setFreezeBoard(true)\n    // If there are no items in the turnedOver array ...\n    if(turnedOver.length === 0){\n      // ... it sets this card's ID into turnedOver state ...\n      setTurnedOver([id])\n      // ... and un-freezes the game boards\n      setFreezeBoard(false)\n    // However, if there is already an item in the array ...\n    } else {\n      // ... we call a function to make sure the user is not clicking the same card again\n      if (isSameCard(id)) return\n      // If so, we just set it again to the turned over array\n      setTurnedOver([turnedOver[0], id])\n      // This is infact a second and separate card, a function is called to chack if these two cards match\n      if (doCardsMatch(id)) {\n        // If the do match, we store the ID in a \"matching-card-array\" and reset the turned-over array so the user can keep on playing\n        setMatchingCards([ ...matchingCards, turnedOver[0], id])\n        // We also need to call another function to refresh the board (seen below)\n        refreshBoard()\n      } else {\n        // Now, if the 2 cards don't match, we give the user 1.5 seconds to see both the cards, and the refresh the gameboard\n        setTimeout(refreshBoard, 1500)\n      }\n    }\n  }\n\n\n  // A simple function that uses the cards ID and checks if the turnedOver array includes the provided ID\n  const isSameCard = (id) => turnedOver.includes(id)\n\n\n  // The function is only excuted if two cards have been selected. \n  const doCardsMatch = (id) => {\n    // The first variable is used to store the clicked card. The ID is found with a find()-method.\n    const clicked1 = cards.find((card) => card.id === id)\n    // The second variable is to store the information on the card that has been turned over. Also uses find method.\n    const clicked2 = cards.find((card) => turnedOver[0] === card.id)\n    // It's then returned if these 2 IDs are the same\n    return clicked1.name === clicked2.name\n  }\n\n\n  // Here's the function that refreshes the board\n  const refreshBoard = () => {\n    // Calls function to set the state back to original, using empty array\n    setTurnedOver([])\n    // Calls function to active the board again so the user can click 2 more tiles\n    setFreezeBoard(false)\n  }\n\n\n  // Here we return all our components, plus some JSX markup for providing must-have props\n  return (\n    <div>\n      <Header/>\n      <div className=\"container\">\n        <div className=\"table__container\">\n          <CardBoard cards={cards} turnedOver={turnedOver} clickHandler={clickHandler} freezeBoard={freezeBoard} matchingCards={matchingCards} />\n        </div>\n      </div>\n      <Footer />\n    </div>\n  );\n}\n\n \n// The app is then exported for index.js to use\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;","// Import of must-have React stuff + My app\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\n// Here our site/app is rendered. All stuff is included in APP, so it's not a lot!\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// I don't really know what this is, but it has something to do with performance, and deleting it gives me a fatal error\nreportWebVitals();"],"sourceRoot":""}